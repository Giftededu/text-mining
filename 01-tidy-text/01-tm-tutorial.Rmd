---
title: "TM Lab 1: Tidy Text, Tokens & Twitter"
author: "LASER TEAM"
date: "`r format(Sys.Date(),'%B %e, %Y')`"
output:
  html_document:
    toc: true
    toc_depth: 3
    toc_float: yes
bibliography: references.bib
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

[INSERT PRESENTATION VIDEO HERE]

## 1. PREPARE

#### Research Questions

Recall from our presentation that one central question to text mining and natural language processing is:

> How do we to **quantify** what a document or collection of documents is about?

For our first lab on text mining in STEM education, we'll explore this question by examining a corpus, or collection, of public posts on Twitter about the Common Core State Standards (CCSS) to better understand public discourse surrounding these standards, particularly as they relate to math education. Specifically, in this lab we'll be applying some basic text mining techniques to address the following questions:

1.  What are the most frequent terms or words used in reference to tweets about the CCSS?

2.  What are the most common phrases used in reference to the CCSS?

3.  How does usage of these top terms and phrases change over time?

4.  What words and hashtags commonly co-occur together, particularly with the word "math"?

#### Section Objectives

To help us better understand the packages, Twitter API tools, and data we'll use during this lab to address these questions, in this section we'll learn to:

a.  **Load Packages** for tidy text mining and using Twitter APIs

b.  **Create a Twitter App** to obtain [authentication](https://developer.twitter.com/en/docs/authentication) credentials, also known as keys and tokens

c.  **Authorize RStudio** to use your app for retrieving data from Twitter

#### Exercise RMarkdown File

Instructions for accessing practice file and completing lab...

### 1a. Load Packages

#### Prior Packages

Let's begin by loading some familiar packages from previous Learning Labs that we'll be using for data wrangling and exploration :

```{r load-libraries, message=FALSE}
library(dplyr)
library(readr)
library(tidyr)
library(ggplot2)
library(readxl)
library(writexl)
library (DT)
```

#### The rtweet Package

![](img/rtweet.jpeg){width="100"}

The `rtweet` package provides users a range of functions designed to extract data from Twitter's REST and streaming APIs and has three main goals:

1.  Formulate and send requests to Twitter's REST and stream APIs.

2.  Retrieve and iterate over returned data.

3.  Wrangling data into tidy structures.

Let's load the `rtweet` package which we'll be using later in this lab to accomplish all three of the goals listed above:

```{r load-rtweet, message=FALSE}
library(rtweet)
```

### 1b. Create a Twitter App

Before you can begin pulling tweets into R, you'll first need to create a Twitter App in your developer account. This section and the section that follows, are borrowed largely from the `rtweet` package by Michael Kearney, and requires that you have set up a Twitter developer account.

You are not required to set up developer account for this institute, but if you are still interested in creating one, [these instructions](https://dev.to/sumedhpatkar/beginners-guide-how-to-apply-for-a-twitter-developer-account-1kh7) succinctly outline the process and you can set one up in about 10 minutes. We have provided the data we'll be using for the Wrangling and Explore parts of the lab on our [GitHub repository](https://github.com/sbkellogg/eci-588/tree/main/unit-2/data) and you can skip to section [2b. Tidy Text] if you are not interested in or unable to set up a Twitter developer account.

#### Steps for Creating your Twitter App

1.  Navigate to [developer.twitter.com/en/apps](https://developer.twitter.com/en/apps/), click the blue button that says, `Create a New App`, and then complete the form with the following fields:

    -   `App Name`: What your app will be called

    -   `Application Description`: How your app will be described to its users

        <p align="center">

        <img src="files/create-app-1.png" alt="create-app-1"/>

        </p>

    -   `Website URLs`: Website associated with app--I recommend using the URL to your Twitter profile

    -   `Callback URLs`: ***IMPORTANT*** enter exactly the following: `http://127.0.0.1:1410`

        <p align="center">

        <img src="files/create-app-2.png" alt="create-app-2"/>

        </p>

    -   `Tell us how this app will be used`: Be clear and honest

        <p align="center">

        <img src="files/create-app-3.png" alt="create-app-3"/>

        </p>

2.  When you've completed the required form fields, click the blue `Create` button at the bottom

3.  Read through and indicate whether you accept the developer terms

    <p align="center">

    <img src="files/create-app-4.png" alt="create-app-4"/>

    </p>

4.  And you're done!

    <p align="center">

    <img src="files/create-app-5.png" alt="create-app-5"/>

    </p>

### 1c. Authorizing RStudio

In order to authorize R to use your Twitter App to retrieve data, you'll need to create a personal Twitter token by completing the following steps:

-   Navigate to [developer.twitter.com/en/apps](https://developer.twitter.com/en/apps) and select your Twitter app
-   Click the tab labeled `Keys and tokens` to retrieve your keys.
-   Locate the `Consumer API keys` (aka "API Secret").

<p align="center">

<img src="files/create-app-6.png" alt="create-app-6"/>

</p>

-   Scroll down to `Access token & access token secret` and click `Create`

<p align="center">

<img src="files/create-app-7.png" alt="create-app-7"/>

</p>

-   Copy and paste the four keys (along with the name of your app) into an R Markdown file file and pass them along to `create_token()`. Note, these keys are named secret for a reason. I recommend setting up your token in a separate R Markdown file than the one that you will eventually share.

```{r api-keys, eval=FALSE}
## store api keys (these are fake example values; replace with your own keys)
app_name <- "Text Mining in Education"
api_key <- "afYS4vbIlPAj096E60c4W1fiK"
api_secret_key <- "bI91kqnqFoNCrZFbsjAWHD4gJ91LQAhdCJXCj3yscfuULtNkuu"
access_token <- "9551451262-wK2EmA942kxZYIwa5LMKZoQA4Xc2uyIiEwu2YXL"
access_token_secret <- "9vpiSGKg1fIPQtxc5d5ESiFlZQpfbknEN1f1m2xe5byw7"

## authenticate via web browser
token <- create_token(
  app = app_name,
  consumer_key = api_key,
  consumer_secret = api_secret_key,
  access_token = access_token,
  access_secret = access_token_secret)
```

If you are interested in viewing an alternate authentication method, you can view `rtweet` Twitter authorization vignette by running the following code:

```{r auth-vignette, eval=FALSE}
vignette("auth")
```

#### Authorization in future R sessions

-   The `create_token()` function should automatically save your token as an environment variable for you. So next time you start an R session [on the same machine], rtweet should automatically find your token.
-   To make sure it works, restart your R session, run the following code, and again check to make sure the app name and `api_key` match.

```{r get-token}
## check to see if the token is loaded
get_token()
```

That's it!

------------------------------------------------------------------------

## 2. WRANGLE

In general, data wrangling involves some combination of cleaning, reshaping, transforming, and merging data (Wickham & Grolemund, 2017). The importance of data wrangling is difficult to overstate, as it involves the initial steps of going from raw data to a dataset that can be explored and modeled (Krumm et al, 2018).

a.  **Search & Subset**. In this section, we introduce new functions from the `rtweet` package to search for and filter tweets and users of interest.
b.  **Tidy Text**. We also introduce the `tidytext` package to both "tidy" and tokenize our tweets in order to create our data frame for analysis.
c.  **Stop Words.** We conclude our data wrangling by using the now familiar `dplyr` package to remove words that don't add much value to our analysis.

### 2a. Search & Subset

This section introduces the following functions from the `rtweet` package for reading Twitter data into R:

-   [`search_tweets()`](https://www.rdocumentation.org/packages/rtweet/versions/0.7.0/topics/search_tweets) Pulls up to 18,000 tweets from the last 6-9 days matching provided search terms. 
-   [`search_tweets2()`](https://www.rdocumentation.org/packages/rtweet/versions/0.7.0/topics/search_tweets) Returns data from **multiple** search queries.
-   [`get_timelines()`](https://www.rdocumentation.org/packages/rtweet/versions/0.7.0/topics/search_tweets) Returns up to 3,200 tweets of one or more specified Twitter users.

#### Search Tweets

Since one of our goals for this Learning Lab and the next is a very simplistic replication of the studies by Wang and Fikis (2019), let's begin by introducing the `search_tweets()` function to try reading into R 5,000 tweets containing the CommonCore hashtag and store as a new data frame called `ccss_tweets`.

Type or copy the following code into your R Markdown file or console and run:

```{r search-tweets, eval=TRUE}
ccss_tweets <- search_tweets(q = "#CommonCore", n=5000)
```

Note that the first argument `q =` that the `search_tweets()` function expects is the search term included in quotation marks and that `n =` specifies the maximum number of tweets to return.

##### ✅ Comprehension Check

View your new `ccss_tweets` data frame using the `glimpse()` function introduced previously to help answer the following questions:

1.  How many tweets did our query using the Twitter API actually return? How many variables?
2.  Why do you think our query pulled in far less than 5,000 tweets requested?
3.  Does our query also include retweets? How do you know?
4.  Does capitalization in your query matter?

#### Using the OR Operator

Wang and Fikis (2019) collected the tweets containing the hashtags \#CommonCore and \#CCSS for 12 months from 2014 to 2015. Unfortunately, a basic Twitter developer account only lets us go back about a week but retrieving tweets the two hashtags identified by the authors is not an issue.

Let's modify our query using the `OR` operator to also include "CCSS" so it will return tweets containing either \#NGSSchat or "ngss" and assign to `ngss_or_tweets`:

```{r or-operator}
ccss_or_tweets <- search_tweets(q = "#commoncore OR #ccss", n=5000)

```

##### ✅ Comprehension Check

Try including both search terms but excluding the `OR` operator to answer the following question:

1.  Does excluding the `OR` operator return more tweets, the same number of tweets, or fewer tweets? Why?
2.  What happens if you remove the hashtag? Does it still return tweets with CommonCore?
3.  What other useful arguments does the `search_tweet()` function contain? Try adding one and see what happens.

Hint: Use the `?search_tweets` help function to learn more about the `q` argument and other arguments for composing search queries.

#### Use Multiple Queries

Although Wang and Fikis (2019) limited their query to the two hashtags used above, at some point you may be interested in a more complex query that includes additional search terms. Unfortunately, the `OR` operator only gets us so far. In order to pass multiple queries , we will need to use the `c()` function to combine our search terms into a single list.

Copy and past the following code to store the results of our query in `ngss_tweets`:

```{r}
ccss_tweets <- search_tweets2(c("#commoncore OR #ccss",
                                '"common core standards"',
                                '"common core state standards"'), 
                             n=5000,
                             include_rts = FALSE)
```

Notice the unique syntax required for the query argument. For example, when "OR" is entered between search terms, `query = "#CommonCore OR #CCSS"`, Twitter's REST API should return any tweet that contains either "\#CommonCore" or "\#CCSS." It is also possible to search for exact phrases using double quotes. To do this, either wrap single quotes around a search query using double quotes, e.g., `q = '"common core standards"'` as we did above, or escape each internal double quote with a single backslash, e.g., `q = "\"common core standards\""`.

To learn more about constructing search terms using the query argument, enter `?search_tweets` in your console and review the documentation for the `q=` argument.

##### ✅ Comprehension Check

1.  Use the `search_tweets` function to create you own custom query for a twitter hashtag or topic(s) of interest.

#### Subset Tweets

As you may have noticed, we have way more data than we need for our analysis and should probably pare it down to just what we'll use.

First let's use the `filter` function introduced in previous labs to subset rows containing only tweets in the English language:

```{r}
ccss_tweets <- filter(ccss_tweets, lang == "en")
```

Now let's select the following columns from our new `ccss_text` data frame:

1.  `screen_name` of the user who created the tweet
2.  `created_at` timestamp for examining changes in sentiment over time
3.  `text` containing the tweet which is our primary data source of interest

```{r select-variables}
ccss_tweets <- select(ccss_tweets,
                 screen_name, 
                 created_at, 
                 text)
```

While not explicitly mentioned in the paper, it's likely the authors removed retweets in their query since a retweet is simply a user reposting someone else's tweet and would duplicate the exact same content of the original.

##### ✅ Comprehension Check

Rewrite our query from the [Using the OR Operator] section and use the `include_rts =` argument to remove any retweets by setting it to `FALSE`. You'll also need to

Extra credit for using the `%>%` pipe operator for keeping your code succinct.

You're output should look something like this:

```{r retweet-argument, eval=TRUE, echo=FALSE}
ccss_tweets <- search_tweets(q = "#commoncore OR #ccss", 
                             n=5000, 
                             include_rts = FALSE,
                             lang = "en") %>%
  select(screen_name, created_at, text)
  

datatable(ccss_tweets)
```

#### Write to Excel File

Finally, let's save our tweet files to use in later exercises since tweets have a tendency to change every minute. We'll save as a Microsoft Excel file since one of our columns can not be stored in a flat file like .csv.

Let's use the `write_xlxs()` function from the `writexl` package just like we would the `write_csv()` function from `dplyr` in Unit 1:

```{r, eval=F}
write_xlsx(ccss_tweets, "data/csss_tweets.xlsx")
```

##### **✅ Comprehension Check**

1.  What happens if you try to write to a flat file like .csv?

#### Other Useful Functions (Optional)

For your own research, you may be interest in exploring posts by specific users rather than topics, key words, or hashtags. Yes, there is a function for that too!

For example, let's create another list containing the usernames of the LASER Institute leads using the `c()` function again and use the `get_timelines()` function to get the most recent tweets from each of those users:

```{r}
fi <- c("sbkellogg", "haspires", "tarheel93", "drcallie_tweets", "AlexDreier")

fi_tweets <- fi %>%
  get_timelines(include_rts=FALSE)
```

Notice that you can use the pipe operator with the `rtweet` functions just like you would other functions from the tidyverse.

And let's use the `sample_n()` function from the `dplyr` package to pick 10 random tweets and use `select()` to select and view just the `screenname` and `text` columns that contains the user and the content of their post:

```{r}
sample_n(fi_tweets, 10) %>%
  select(screen_name, text)
```

The `rtweet` package also has handy `ts_plot` function built into `rtweet` to take a very quick look at how far back our data set goes:

```{r ts_plot}
ts_plot(ccss_tweets, by = "days")
```

Notice that this effectively creates a `ggplot` time series plot for us. I've included the `by =` argument which by default is set to "days". It looks like tweets go back 9 days which the rate limit set by Twitter.

Try changing it to "hours" and see what happens.

##### ✅ Comprehension Check

To conclude Section 2a, try one of the following search functions from the `rtweet` vignette:

1.  `get_timelines()` Get the most recent 3,200 tweets from users.
2.  `stream_tweets()` Randomly sample (approximately 1%) from the live stream of all tweets.
3.  `get_friends()` Retrieve a list of all the accounts a user follows.
4.  `get_followers()` Retrieve a list of the accounts following a user.
5.  `get_favorites()` Get the most recently favorited statuses by a user.
6.  `get_trends()` Discover what's currently trending in a city.
7.  `search_users()` Search for 1,000 users with the specific hashtag in their profile bios.

We've only scratched the surface of the number of functions available in the `rtweets` package for searching Twitter. To learn more about the `rtweet` package, you can find full documentation on CRAN at: [\<https://cran.r-project.org/web/packages/rtweet/rtweet.pdf\>](https://cran.r-project.org/web/packages/rtweet/rtweet.pdf){.uri}

Or use the following function to access the package vignette:

```{r rtweet-vignette, eval=F}
vignette("intro", package="rtweet")
```

### 2b. Tidy Text

![](img/tidytext.png){width="100"}

Text data, by it's very nature is ESPECIALLY untidy and sometimes referred to as "unstructured." The `tidytext` package provide functions and supporting data sets to allow conversion of text to and from tidy formats, and to switch seamlessly between tidy tools and existing text mining packages.

In [Chapter 1 of Text Mining with R](https://www.tidytextmining.com/tidytext.html), Silge and Robinson (2018) define the tidy text format as a table with one-token-per-row. A **token** is a meaningful unit of text, such as a word, two-word phrase (bigram), or sentence that we are interested in using for analysis. And **tokenization** is the process of splitting text into tokens.

This one-token-per-row structure is in contrast to the ways text is often stored for text analysis, perhaps as strings in a corpus object or in a document-term matrix. For tidy text mining, the token that is stored in each row is most often a single word, but can also be an n-gram, sentence, or paragraph.

For this part of our workflow, our goal is to transform our `ccss_tweets` data from this:

    ## # A tibble: 6 x 3
    ##   Role   Resource                             text                              
    ##   <chr>  <chr>                                <chr>                             
    ## 1 Teach… Live Webinar                         "levels ofquestioning and revised…
    ## 2 Teach… Online Learning Module (e.g. Call f… "None, really."                   
    ## 3 Teach… Online Learning Module (e.g. Call f… "In any of the modules when a tea…
    ## 4 Teach… Online Learning Module (e.g. Call f… "Understanding the change"        
    ## 5 Teach… Online Learning Module (e.g. Call f… "overview of reasons for change"  
    ## 6 Teach… Online Learning Module (e.g. Call f… "online--allowed me to do it on m…

Into a "tidy text" format that looks more like the familiar tibble:

    ## # A tibble: 6 x 3
    ##   Role    Resource                                                    word      
    ##   <chr>   <chr>                                                       <chr>     
    ## 1 Teacher Live Webinar                                                levels    
    ## 2 Teacher Live Webinar                                                ofquestio…
    ## 3 Teacher Live Webinar                                                and       
    ## 4 Teacher Live Webinar                                                revised   
    ## 5 Teacher Live Webinar                                                blooms    
    ## 6 Teacher Online Learning Module (e.g. Call for Change, Understandin… none

Later we'll learn about other data structures for text analysis like the document-term matrix and corpus objects. For now, however, working with the familiar tidy data frame allows us to take advantage of popular packages that use the shared tidyverse syntax and principles for wrangling, exploring, and modeling data.

Let's go ahead and load it:

```{r load-tidytext, message=FALSE}
library(tidytext)
```

As we'll Learn first hand later in this lab, using tidy data principles can make many text mining tasks easier, more effective, and consistent with tools already in wide use. Much of the infrastructure needed for text mining with tidy data frames already exists in `tidyverse` packages with which we've already been introduced.

For a more comprehensive introduction to the `tidytext` package, I cannot recommend enough the free online book, [Text Mining with R: A Tidy Approach](https://www.tidytextmining.com) by Silge and Robinson (2018).

**Attention:** From this point forward, we'll also use a shared dataset constructed with the [Twitter Academic Research product track](https://developer.twitter.com/en/solutions/academic-research/products-for-researchers) that allows for a much greater number of tweets to be accessed over a far greater period of time.

Let's use the `readxl` package highlighted in Section 1 and the `read_xlsx()` function to read in the data stored in the data folder of our R project:

```{r}
ccss_tweets <- read_xlsx("data/csss_tweets.xlsx")
```

#### Tokenize Text {data-link="2b. Tidy Text"}

The `tidytext` package provides the incredibly powerful `unnest_tokens()` function to tokenize by commonly used units of text (including tweets!) and convert them to a one-token-per-row format.

Let's tokenize our tweets by using this function to split each tweet into a single row to make it easier to analyze:

```{r}
tweet_tokens <- unnest_tokens(ccss_tweets, 
                              output = word, 
                              input = text, 
                              token = "tweets")
```

There is A LOT to unpack with this function. First notice that `unnest_tokens` expects a data frame as the first argument, followed by two column names. The first is an output column name that doesn't currently exist but will be created as the text is unnested into it (`word`, in this case). This if followed by the input column that the text comes from which we uncreatively named `text`. Also notice:

-   Other columns, such as `Role` and `Resource`, are retained.

-   All punctuation has been removed.

-   Tokens have been changed to lowercase, which makes them easier to compare or combine with other datasets. However, we can use the `to_lower = FALSE` argument to turn off this behavior).

Finally, we used the specialized `“tweets”` tokenizer in the `tokens =` argument that is very useful for dealing with Twitter text or other text from online forums in that it retains hashtags and mentions of usernames with the \@ symbol.

Before we move any further let's take a quick look at the most common word in our common core dataset:

```{r}
tweet_tokens %>%
  count(word, sort = TRUE) 
```

Well, first of many of these tweets are clearly about the common core, but beyond that it's a bit hard to tell because there are so many "stop words" like "the", "to", "and", "in" that don't carry much meaning by themselves.

### 2c. Stop Words

Often in text analysis, we will want to remove these stop words if they are not useful for an analysis. The `stop_words` dataset in the tidytext package contains stop words from three lexicons. We can use them all together, as we have here, or [`filter()`](https://dplyr.tidyverse.org/reference/filter.html) to only use one set of stop words if that is more appropriate for a certain analysis.

Let's take a closer the lexicons and stop words included in each:

```{r}
DT::datatable(stop_words)
```

#### The `anti_join` Function

In order to remove these stop words, we will use function called `anti_join()` that looks for matching values in a specific column from two datasets and returns rows from the original dataset that have no matches like so:

![](img/anti-join.png)

For a good overview of the different `dplyr` joins see here: <https://medium.com/the-codehub/beginners-guide-to-using-joins-in-r-682fc9b1f119>

Now let's remove stop words like "the" and "a" that don't help us learn much about what people are tweeting about the state standards.

```{r}
tidy_tweets <- anti_join(tweet_tokens,
                         stop_words,
                         by = "word")

tidy_tweets
```

Notice that we've specified the `by =` argument to look for matching words in the `word` column for both data sets and remove any rows from the `tweet_tokens` dataset that match the `stop_words` dataset. Remember when we first tokenized our dataset I conveniently chose `output = word` as the column name because it matches the column name `word` in the `stop_words` dataset contained in the `tidytext` package. This makes our call to `anti_join()`simpler because `anti_join()` knows to look for the column named `word` in each dataset. However this wasn't really necessary since `word` is the only matching column name in both datasets and it would have matched those columns by default.

#### Custom Stop Words

Before wrapping up, let's take a quick count of the most common words in `tidy_tweets` data frame:

```{r}
count(tidy_tweets, word, sort = T)
```

Notice that the nonsense word "amp" is in our top tens words. Let's rewrite our stop word code to add a custom stop word to filter out rows with "amp" in them:

```{r}
tidy_tweets <-
  tweet_tokens %>%
  anti_join(stop_words, by = "word") %>%
  filter(!word == "amp")
```

Note that we could extend this filter to weed out any additional words that don't carry much meaning but skew our data by being so prominent.

##### ✅ Comprehension Check

We've created some unnecessarily lengthy code to demonstrate some of the steps in the tidying process. Rewrite the tokenization and removal of stop words processes into a more compact series of functions and save your data frame as `tidy_tweets`.

## 3. EXPLORE

Now that we have our tweets tidied and sentiments joined, we're ready for a little data exploration. As highlighted in Unit 1, calculating summary statistics, data visualization, and feature engineering (the process of creating new variables from a dataset) are a key part of exploratory data analysis. One goal in this phase is explore questions that drove the original analysis and develop new questions and hypotheses to test in later stages. Topics addressed in Section 3 include:

a.  **c**

b.  **Time Series**. We take a quick look at the date range of our tweets and compare number of postings by standards.

c.  

d.  

e.  

### 3c. Time Series

1.  Use `ts_plot` with the `group_by` function to compare the number of tweets over time by Next Gen and Common Core `standards`
2.  Which set of standards is Twitter users talking about the most?

Hint: use the `?ts_plot` help function to check the examples to see how this can be done.

Your line graph should look something like this:

```{r, echo=F}
ccss_tweets %>%
  ts_plot(by = "hours")
```
